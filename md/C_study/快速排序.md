## 🚀 快速排序详解（C语言实现）

---

[TOC]



### **1️⃣ 核心思想与流程**

#### 📌 分治策略三步走  
1. **选基准**：从数组中选取一个元素作为基准值（Pivot）。  
2. **分区**：将数组分为左右两部分，左侧 ≤ 基准值，右侧 ≥ 基准值。  
3. **递归**：对左右子数组重复上述过程，直至子数组长度为1。

#### 🎯 性能优势  
- **平均时间复杂度**：\(O(n \log n)\)（大多数场景下的最优选择）  
- **原地排序**：仅需 \(O(\log n)\) 栈空间（递归深度）

---

### **2️⃣ 关键步骤拆解**

#### 📌 分区操作（Partition）示意图  
```text
原始数组: [6, 3, 8, 2, 9, 1]  
选择基准值6 → 分区后: [3, 2, 1, 6, 8, 9]  
           ↑ pivot  
左子数组[3,2,1] 和 右子数组[8,9] 继续递归排序
```

---

### **3️⃣ C语言实现代码**

#### 📌 完整代码（含详细注释）  
```c
#include <stdio.h>

/* 交换两个整数的值 */
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

/* 分区函数：返回基准值的最终位置 */
int partition(int arr[], int low, int high) {
    int pivot = arr[low];   // 选择第一个元素为基准（可优化为三数取中）
    int left = low;         // 左指针初始化
    int right = high;       // 右指针初始化

    while (left < right) {
        // 从右向左扫描，找到第一个小于基准的元素
        while (left < right && arr[right] >= pivot) right--;
        // 从左向右扫描，找到第一个大于基准的元素
        while (left < right && arr[left] <= pivot) left++;
        // 交换左右指针处的元素
        if (left < right) swap(&arr[left], &arr[right]);
    }
    // 将基准值交换到正确位置（left==right时的位置）
    swap(&arr[low], &arr[left]);
    return left;
}

/* 快速排序主函数 */
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pivotPos = partition(arr, low, high);  // 获取基准位置
        quickSort(arr, low, pivotPos - 1);         // 递归排序左子数组
        quickSort(arr, pivotPos + 1, high);        // 递归排序右子数组
    }
}

/* 测试代码 */
int main() {
    int arr[] = {6, 3, 8, 2, 9, 1};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("排序前: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);

    quickSort(arr, 0, n - 1);  // 执行排序

    printf("\n排序后: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);

    return 0;
}
```

---

#### 🔍 代码关键点解析  
| 代码部分               | 功能说明                             |
| ---------------------- | ------------------------------------ |
| `swap()`               | 实现元素交换，确保原地排序           |
| `partition()` 中的循环 | 双指针从两端向中间扫描，确保左小右大 |
| `quickSort()` 递归     | 分治策略的核心，对左右子数组分别处理 |

---

#### 🖥️ 输出结果  
```text
排序前: 6 3 8 2 9 1 
排序后: 1 2 3 6 8 9 
```

---

### **4️⃣ 复杂度与优化**

#### 📊 复杂度对比  
| 情况     | 时间复杂度      | 空间复杂度    | 发生条件                      |
| -------- | --------------- | ------------- | ----------------------------- |
| 平均情况 | \(O(n \log n)\) | \(O(\log n)\) | 基准值选择适中                |
| 最坏情况 | \(O(n^2)\)      | \(O(n)\)      | 数组已有序且基准总选首/尾元素 |

#### ⚡ 优化策略  
1. **三数取中法**：选择首、中、尾三个元素的中值作为基准。  
   ```c
   // 优化后的基准选择代码示例
   int mid = low + (high - low)/2;
   if (arr[mid] > arr[high]) swap(&arr[mid], &arr[high]);
   if (arr[low] > arr[high]) swap(&arr[low], &arr[high]);
   if (arr[mid] > arr[low]) swap(&arr[mid], &arr[low]);
   int pivot = arr[low];
   ```
2. **尾递归优化**：减少递归调用栈深度。  
3. **插入排序混合**：当子数组长度较小时（如≤15），改用插入排序。

---

### **5️⃣ 稳定性问题示例**  
```text
原始序列: [3(红), 2, 3(蓝)]  
选择基准值3(红) → 分区后可能变为 [2, 3(蓝), 3(红)]  
两个3的相对顺序改变 → 不稳定排序
```

---

### **6️⃣ 与其他排序算法对比**  
| 算法     | 平均时间复杂度  | 空间复杂度    | 稳定性 | 适用场景               |
| -------- | --------------- | ------------- | ------ | ---------------------- |
| 快速排序 | \(O(n \log n)\) | \(O(\log n)\) | 不稳定 | 大规模数据、内存敏感   |
| 归并排序 | \(O(n \log n)\) | \(O(n)\)      | 稳定   | 需要稳定性、外部排序   |
| 堆排序   | \(O(n \log n)\) | \(O(1)\)      | 不稳定 | 实时系统、内存严格受限 |
| 插入排序 | \(O(n^2)\)      | \(O(1)\)      | 稳定   | 小规模或基本有序数据   |

---

### **7️⃣ 实战训练**  
**题目**：修改代码实现降序排序  
**提示**：  
1. 修改分区逻辑中的比较方向（将 `>=` 改为 `<=`，`<=` 改为 `>=`）。  
2. 调整注释中的“左小右大”为“左大右小”。

---

通过掌握快速排序的核心思想与优化技巧，可高效处理大规模数据排序任务！ 🚀