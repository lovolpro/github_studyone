## 📝 选择排序详解（C语言实现）

---

[TOC]

------



### **1️⃣ 核心定义与特性**

#### 📌 算法思想

通过 **“选择极值 + 交换位置”** 的方式，每次从无序区选出最小（或最大）元素，移动到有序区末尾，逐步完成排序。

#### 📊 关键特性  

| 特性           | 说明                                         |
| -------------- | -------------------------------------------- |
| **时间复杂度** | O(n²)（所有情况）                            |
| **空间复杂度** | O(1)（原地排序）                             |
| **稳定性**     | 不稳定（交换可能破坏相等元素的原始顺序）     |
| **适用场景**   | 小规模数据、交换成本低、对稳定性无要求的场景 |

---

### **2️⃣ 算法流程示意图**  

```text
初始数组: [118, 101, 105, 127, 112]

第1趟排序 → 选出101与118交换 → [101, 118, 105, 127, 112]
第2趟排序 → 选出105与118交换 → [101, 105, 118, 127, 112]
第3趟排序 → 选出112与118交换 → [101, 105, 112, 127, 118]
第4趟排序 → 选出118与127交换 → [101, 105, 112, 118, 127]
```

---

### **3️⃣ C语言实现代码**

#### 📌 代码实现

```c
#include <stdio.h>

/**
 * @brief 选择排序（升序）
 * @param arr 待排序数组
 * @param n   数组长度
 */
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {    // 已排序部分末尾索引i（0 ~ n-2）
        int minIndex = i;                // 初始化最小值索引为未排序部分首元素
        // 遍历未排序部分，寻找最小值索引
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 将最小值交换到已排序部分末尾
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

// 测试示例
int main() {
    int arr[] = {118, 101, 105, 127, 112};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("排序前: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);

    selectionSort(arr, n);  // 执行排序

    printf("\n排序后: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);

    return 0;
}
```

---

#### 🔍 代码解析  

| 代码部分         | 功能说明                                                     |
| ---------------- | ------------------------------------------------------------ |
| **外层循环 `i`** | 控制已排序部分的末尾位置（从0到n-2），共需n-1趟排序          |
| **内层循环 `j`** | 在未排序部分（`i+1`到`n-1`）中遍历，寻找最小值索引 `minIndex` |
| **交换操作**     | 将最小值 `arr[minIndex]` 与未排序部分首元素 `arr[i]` 交换    |

---

#### 🖥️ 输出结果  

```text
排序前: 118 101 105 127 112 
排序后: 101 105 112 118 127 
```

---

### **4️⃣ 关键问题与注意事项**

#### ⚠️ 稳定性问题  

**示例**：排序 `[5, 8, 5, 2]`  

- 第1趟选出最小值2，与第一个5交换 → `[2, 8, 5, 5]`  
- 第2趟在剩余 `[8, 5, 5]` 中选出5，与8交换 → `[2, 5, 8, 5]`  
- **结果**：两个5的原始顺序被破坏 → **不稳定排序**  

---

#### ⚙️ 性能优化建议  

1. **双指针优化**：同时寻找最小值和最大值，减少循环次数（时间复杂度仍为O(n²)）。  
2. **提前终止**：若某趟未发生交换，说明数组已有序（但优化效果有限）。  

---

### **5️⃣ 与其他排序算法对比**  

| 算法     | 平均时间复杂度 | 空间复杂度 | 稳定性 | 适用场景             |
| -------- | -------------- | ---------- | ------ | -------------------- |
| 选择排序 | O(n²)          | O(1)       | 不稳定 | 小规模数据、简单实现 |
| 冒泡排序 | O(n²)          | O(1)       | 稳定   | 教学示例、小规模数据 |
| 插入排序 | O(n²)          | O(1)       | 稳定   | 部分有序数据         |
| 快速排序 | O(n log n)     | O(log n)   | 不稳定 | 大规模数据、内存敏感 |

---

### **6️⃣ 实战训练**

**题目**：修改代码实现降序排序  
**提示**：调整内层循环的比较条件（将 `<` 改为 `>`）并修改变量名 `minIndex` 为 `maxIndex`。
